
<!doctype html>
<!-- The Time Machine GitHub pages theme was designed and developed by Jon Rohan, on Feb 7, 2012. -->
<!-- Follow him for fun. http://twitter.com/jonrohan. Tail his code on https://github.com/jonrohan -->
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <link rel="stylesheet" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" href="stylesheets/github-dark.css">
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script type="text/javascript" src="javascripts/script.js"></script>
    <title>Odfaeg</title>
    <meta name="description" content="ODFAEG">
    <meta name="viewport" content="width=device-width,initial-scale=1">
  </head>
  <body>
  <div class="wrapper">
  <header>
    <h1 class="title">LastProject : ODFAEG</h1>
    <p class="tagline">Gestionnaire d'entités persos : </p>
  </header>
   <div id="container">
        <div id="main" role="main">
          <div class="download-bar">
            <div class="inner">
              <a href="https://github.com/LaurentDuroisin/ODFAEG/tarball/master" class="download-button tar"><span>Download</span></a>
              <a href="https://github.com/LaurentDuroisin/ODFAEG/zipball/master" class="download-button zip"><span>Download</span></a>
              <a href="menu">Documentation</a>
              <a href="http://odfaeg.yourboardpro.com/index.php">Forum</a>
              <a href="https://github.com/LaurentDuroisin/ODFAEG" class="code">View Odfaeg on GitHub</a>
              <a href="cv">CV</a>
              <a href="tfe">Travail de fin d'études</a>
            </div>
          <span class="blc"></span><span class="trc"></span>
        </div>
          <article class="markdown-body">
  <p>
  Comme pour la classe odfaeg::graphic::Entity, pour définir son propre type de gestionnaire d'entité, il faut hériter d'une classe,<br/>
  et cette classe se nomme odfaeg::graphic::SceneManager.<br/>
  Il y a également plusieurs méthodes à redéfinir, que voici : <br/>
  std::vector<Entity*> getEntities(std::string expression) : Retourne toutes les entités de tel(s) type(s)<br/>
  Par exemple, manager.getEntities("E_WALL") retournera toutes les entités de type (ou appartenant au groupe d'entités) "E_WALL".<br/>
  void checkVisibleEntities() : Recherche toutes les entités visibles pour chaque composant de rendu. (celles qui se trouvent<br/>
  dans le champ de vision de la caméra)<br/>
  </p>
  <p>  
  std::vector<Entity*> getVisibleEntities (std::string expression) : renvoie tout les entités visible de tel(s) type(s).<br/>
  std::vector<Entity*> getEntitiesInBox (physic::BoundingBox rect, std::string expression) : Retourne toutes les entités de <br/>
  tel(s) type(s) se trouvant dans la boîte englobante passée en paramètre.<br/>
  bool collide (Entity* entity) : Recherche si une entité est en collision avec une autre entité.<br/>
  bool collide (Entity* entity, math::Vec3f position) : Recherche si une entité est en collision lorsqu'elle <br/>
  se trouve à la position passée en paramètre.<br/>
  </p>
  <p>
  bool collide (Entity* entity, math::Ray ray) : Recherche si une entité est en collision avec une autre entité <br/>
  si on la déplace suivant le rayon passé en paramètre.<br/>
  void generate_map(std::vector<Tile*> tGrounds, std::vector<Wall*> tWalls, math::Vec2f tileSize, physic::BoundingBox& zone)
    <br/> : génère une map (sol + contours) aléatroirement, de taille spécifiée; tGrounds sont les tiles du sol, <br/>
  tWalls sont les murs du contours (coins et bords), les tiles du sols sont choisies aléatoirement, <br/>
  tileSize est la taille d'un carré du terrain,<br/>
  zone est la boîte englobante du terrain.<br/>
  void moveEntity(Entity *entity, float x, float y, float z) : <br/>
  Déplace l'entité passée en paramètre.<br/>
  </p>
  <p>
  bool addEntity(Entity *entity)<br/>
  Ajoute une entités dans le gestionnaire, si une entité identique s'y trouve déjà, alors, la méthode retourne faux.<br/>  
  
  BaseChangementMatrix getBaseChangementMatrix() : <br/>
  Renvoie la matrice de changement de base, celle-ci permet de passer des coordonnées 2D en coordonnée 2D isométrique <br/>
  par exemple. <br/>
  </p>
  <p>
  std::vector<math::Vec2f> getPath(Entity* entity, math::Vec2f finalPos) <br/>
  Retourne le chemin à parcourir par une entité pour atteindre la position passé en paramètre. <br/>
  (N'oubliez pas de prendre en compte les collisions) <br/>
  std::vector<CellMap*> getCasesMap() <br/>
  Retourne toutes les cases de la grille virtuelle contenant les entités. <br/>  
  <p>  
  bool removeEntity(Entity* entity) : Supprime l'entité (sans la supprimer de la mémoire) <br/>
  bool deleteEntity(Entity* entity) : Supprime l'entité de la mémoire.<br/>
  Entity* getEntity(int id) : retourne l'entité d'id passé en paramètre.<br/>
  </p>
  </article>
  </div>
  </div>
  </div>
  </body>
  </html>
