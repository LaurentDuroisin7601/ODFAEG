
<!doctype html>
<!-- The Time Machine GitHub pages theme was designed and developed by Jon Rohan, on Feb 7, 2012. -->
<!-- Follow him for fun. http://twitter.com/jonrohan. Tail his code on https://github.com/jonrohan -->
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <link rel="stylesheet" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" href="stylesheets/github-dark.css">
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script type="text/javascript" src="javascripts/script.js"></script>
    <title>Odfaeg</title>
    <meta name="description" content="ODFAEG">
    <meta name="viewport" content="width=device-width,initial-scale=1">
  </head>
  <body>
  <div class="wrapper">
  <header>
    <h1 class="title">LastProject : ODFAEG</h1>
    <div id="container">
    <p class="tagline">Les entités : </p>
  </header>
  <div id="container">
        <div id="main" role="main">
          <div class="download-bar">
            <div class="inner">
              <a href="https://github.com/LaurentDuroisin/ODFAEG/tarball/master" class="download-button tar"><span>Download</span></a>
              <a href="https://github.com/LaurentDuroisin/ODFAEG/zipball/master" class="download-button zip"><span>Download</span></a>
              <a href="menu">Documentation</a>
              <a href="http://odfaeg.yourboardpro.com/index.php">Forum</a>
              <a href="https://github.com/LaurentDuroisin/ODFAEG" class="code">View Odfaeg on GitHub</a>
              <a href="cv">CV</a>
              <a href="tfe">Travail de fin d'études</a>
            </div>
          <span class="blc"></span><span class="trc"></span>
        </div>
          <article class="markdown-body">
    <h1>Les entités de haut niveau.</h1>
      <p>
      Les entités de bas niveau (celles héritant de la classe odfaeg::graphic::drawable) peuvent ne pas suffire pour des jeux<br/>
      plus complexe, c'est pourquoi ODFAEG possède ses propres type d'entités.<br/>
      Toutes ces entités héritent de la classe odfaeg::graphic::Entity.<br/>
      Les entités possèdent également plusieurs propriétés intéressantes : <br/>
      <ul>
      <li>Une liste de faces.</li>
      <li>Une matrice de transformation.</li>
      <li>Un type.</li>
      <li>Une liste d'entités enfant.</li>
      <li>Une entité parent.</li>
      <li>Un id.</li>
      <li>Des états. (Pouvant être de n'importe quel type)</li>
      <li>Une hiérarchie de volumes de collision.</li>
      </ul>
      </p>
      <p>
      Les entités tout comme les widgets de QT peuvent donc avoir plusieurs entités enfants et une entité parent afin<br/>
      de constituer une hiérarchie, ceci implique que tout changement de proriété affectant une entité parente,<br/>
      affectera aussi les propriétés des entités enfants de celle-ci.<br/>
      
      Par exemple si vous avez une entité parente A qui contient deux entités enfantes B et C, par défaut, lorsque l'on déplacera<br/> 
      l'entité A, les entités B et C le seront également. (Même chose en ce qui concerne les autres type de transformations)<br/>
      </p>
      
      <br/><b>Les faces : </b><br/>
      <p>
      
      Les faces continnent elles aussi plusieurs propriétés intéressantes tel que : <br/>
      
      <ul>
      <li>Un tableau de sommet.</li>
      <li>Une matrice de transformation.</li>
      <li>Un matériel.</li>
      </ul>
      </p>
      <br/><b>Les matériaux : </b><br/>
      <p>
      Les matériaux peuvent contenir également quelques propriétés intéressantes tels que : <br/>
      
      <ul>
      <li>Une ou plusieurs textures.</li>
      <li>L'intensité de la composante spéculaire.</li>
      <li>La puissance de la composante spéculaire.</li>
      <li>Les indices de réfractions et de disfraction du matériel.</li>
      <li>Une "bumpmap". (Une texture de relief de la texture de la face utilisée pour calculer l'éclairage sur la texture)</li>
      </ul>
      </p>
      <h1>Quelque exemples d'entités : </h1>
      <p>
      Les tiles (odfaeg::graphic::Tile) : celles-ci contiennent une seule face composée de quatre sommets.<br/>
      Les décors (odfaeg::graphic::g2d::Decor) : Décors en 2D, même chose que les tiles à part que ceux-ci possèdes un matrices générant des ombres.<br/>
      Les animations : celles-ci possèdent un groupe d'entités (des frames) qui seront affichées les unes après les autres.<br/>
      Les grandes tiles (odfaeg::graphic::BigTile) : celles-ci sont composée de plusieurs tiles afin de former par exemple un terrain.<br/>
      Les murs (odfaeg::graphic::g2d::Wall) : ceux-ci contiennent une matrice de projection des ombres, et un id pour chaque type de murs qui <br/>
      est utilisé pour la génération de bord de carte et de labyrinthes. <br/>
      Les lumières ponctuelles : ce sont juste des lumières en forme de cercles ou d'éllipse. <br/>
      </p>
      <h1>Les entités par défaut de ODFAEG.</h1>
        <p>       
        Chaque entité ODFAEG doit être créée à partir d'une factory : un objet de la classe EntityFactory, vous devez donc en déclaré un dans la classe qui.<br/>
        Hérite de la classe Application.<br/>

        <pre><code>
          odfaeg::graphic::EntityFactory entityFactory;
        </code></pre>
        <br/><b>Les tiles : </b><br/>
        
        Le constructeur de la classe odfaeg::graphic::Tile attend plusieurs paramètres : <br/>
        <ul>
        <li>Le premier est un pointeur vers une texture, qui sera placée sur le quadrilatère formé par les 4 sommets de la tile.</li>
        <li>Le second est la position de la tile. (tuile)</li>
        <li>Le troisième est la taille de la tile.</li>
        <li>Le quatrième est la partie de la texture qui sera placée sur le quadrilatère.</li>
        <li>Le cinquième est la factory.</li>        
        </ul>
        Les deux derniers paramètres sont la couleur de la tile (blanc par défaut) et un pointeur vers une entité parente (null par défaut).<br/>

        
        </p>
        <p>
        <br/><b>Les grandes tiles et le sol.</b><br/>
        
        Celles-ci sont simplement des groupes de tiles dont les bords se touchent.<br/>
        
        Le constructeur de cette classe n'attend que 2 paramètres : <br/>
        <ul>
        <li>Le premier est la position.</li>
        <li>Le second est l'entity factory.</li>
        <li>Les deux derniers sont utilisé par le générateur de terrain : la taille d'une tile et le nombre de tiles par ligne.</li>
        </ul>
        
        La méthode addTile permet d'ajouter une tile au terrain, elle attend en paramètre un pointeur sur la tile à ajouter,<br/>
        les deux paramètres suivants sont utilisé par la générateur de terrain : la position de la tile et un tableau pour la hauteur des 4 coins de la tile.<br/>
            
        La méthode getHeight en 3D permet de récupérer la hauteur du terrain en un point bien précis, elle attend en paramètre un point et une référence pour récupérer la hauteur du terrrain.<br/>
        La méthode renvoie un booléen qui renvoie vrai si le point est sur le terrain.<br/>
        Si le terrain est en 2D, la hauteur renvoyée est la position en y du point.<br/>
        
        <br/><b>Les décors : </b><br/>
        </p>
        <p>
        
        Le constructeur de la classe odfaeg::graphic::g2d::Decor attend plusieurs paramètres également :<br/>
        
        <ul>
        <li>Le premier est un pointeur sur la tile utilisée pour afficher le décor</li>
        <li>Le second, est un pointeur vers une lumière (par exemple le soleil) pour calculer la matrice de transformation des ombres.</li>
        <li>Le troisième, est l'entity factory.</li>
        </ul>
            
        <br/><b>Les murs : </b><br/>
        
          Le constructeur de la classe odfaeg::graphic::g2d::Wall prend plusieurs paramètres dont : <br/>
          <ul>
          <li>Un pointeur vers la tile du mur.</li>
          <li>Le type du mur. (Par exemple TOP_LEFT pour le mur en haut à gauche.)</li>
          <li>Le troisième est un pointeur vers une lumière (par exemple le soleil) pour calculer la matrice de transformation des ombres.</li>
          <li>Le quatrième est l'entity factory.</li>
          </ul>
        </p>
        <br/><b>Les animations : </b><br/>
        <p>
          Le constructeur de la classe odfaeg::graphic::Anim attend 4 paramètres : <br/>
          <ul>
          <li>le taux de rafraichissement.</li>
          <li>la position de l'animation.</li>
          <li>la taille de l'animation.</li>
          <li>l'entity factory.</li>
          <li>Le dernier paramètre est un pointeur vers une entité parente. (null par défaut)</li>
          </ul>
          
          La méthode setInterpolationLevel permet de modifier le niveau d'interpolation de l'animation.<br/>
          La méthode addFrame permet d'ajouté une frame à l'animation.<br/>
          Il est possible d'ajouter une animation enfant d'une autre animation, dans ce cas, les frames des animations<br/>
          enfant seront changée en même temps que celles des animations parents.<br/>
          Ceci est utile dans le cas des animations squelettique, si par exemple, vous avez un personnage et un pantalon,<br/>
          et vous souhaiter que les frames et les sommets de l'animation des jambes pantalon changent en même temps que celles de l'animation des jambes<br/>
          du personnage.
          Les animations parentes et enfant doivent alors avoir le même nombre de frames.<br/>
        </p>
        <p>
        <br/><b>Les lumières ponctuelles : </b><br/>
        
          Avec ODFAEG les lumières ne sont rien d'autre que des formes dont le dégradé est calculé en fonction de différent paramètres qui sont : <br/>
          
          <ul>
          <li>La normalmap de la vue.</li>
          <li>La bumpmap des matériaux.</li>
          <li>La distance par rapport à la source lumineuse.</li>
          <li>Les composantes spéculaires des matériaux.</li>
          </ul>
          
          Le constructeurs de la classe odfaeg::graphic::g2d::PonctualLight attend plusieurs paramètre.<br/>
          
          -Le premier est le centre de la lumière.<br/>
          -Les trois suivants sont les rayons en x, y et z de la lumière.<br/>
          -Le suivant est l'intensité de la lumière.<br/>
          -Le suivant est la couleur de la lumière.<br/> 
          -Le suivant est la qualité de la lumière.<br/>
          -L'avant dernier est l'entity factory.<br/>
          -Et le dernier est un pointeur vers une entité parente. (null par défaut)<br/>

          <br/><b>Créer des entités : </b><br/>
        Pour créer une (par exemple une tile) vous devez utiliser la factory comme ceci en appelant la méthode make_entity, celle-ci prend un paramètre template : <br/>
        le type d'entité que vous souhaiter créer, il vous suffit ensuite de passer les paramètres de la classe tile à la méthode make_entity.<br/>
        <pre><code>entityFactory.make_entity<Tile>(tm.getResourceByAlias("WATER"), Vec3f(0, 0, 0), Vec3f(120, 60, 0),sf::IntRect(0, 0, 100, 50), entityFactory)</code></pre>
            <br/><b>Ajouter une entité au monde : </b><br/>
            Pour celà il suffit de récupérer le monde de l'application et d'appelé la méthode addEntity comme ceci :
            <pre><code>w = entityFactory.make_entity<g2d::Wall>(entityFactory.make_entity<Tile>(tm.getResourceByAlias("WALLS"), Vec3f(0, 0, 0), Vec3f(100, 100, 0), sf::IntRect(100, 200, 100, 100), entityFactory),g2d::Wall::TOP_LEFT, &g2d::AmbientLight::getAmbientLight(), entityFactory);
            w->getChildren()[0]->getFace(0)->getMaterial().setTexId("WALLS");
            w->setPosition(Vec3f(0, 130, 130 + w->getSize().y * 0.5f));
            w->setLayer(1);
            getWorld()->addEntity(w);</code></pre>
          
          Voila maintenant vous savez comment créer ces différentes entités par défaut afin de les afficher dans <br/>
          la fenêtre de rendu.<br/>
          Cependant ceci ne sera pas optimal car vous risquer d'afficher des entités qui ne sont pas visible.<br/<
          Dans le prochain chapitre nous allons voir comment optimiser cela à l'aide du gestionnaire d'entités!<br/>
          </p>
  </body>
</html>
