
<!doctype html>
<!-- The Time Machine GitHub pages theme was designed and developed by Jon Rohan, on Feb 7, 2012. -->
<!-- Follow him for fun. http://twitter.com/jonrohan. Tail his code on https://github.com/jonrohan -->
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <link rel="stylesheet" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" href="stylesheets/github-dark.css">
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script type="text/javascript" src="javascripts/script.js"></script>
    <title>Odfaeg</title>
    <meta name="description" content="ODFAEG">
    <meta name="viewport" content="width=device-width,initial-scale=1">
  </head>
  <body>
  <div class="wrapper">
  <header>
    <h1 class="title">LastProject : ODFAEG</h1>
    <p class="tagline">Les composants de rendu : </p>
  </header>
  <div id="container">
        <div id="main" role="main">
          <div class="download-bar">
            <div class="inner">
              <a href="https://github.com/LaurentDuroisin/ODFAEG/tarball/master" class="download-button tar"><span>Download</span></a>
              <a href="https://github.com/LaurentDuroisin/ODFAEG/zipball/master" class="download-button zip"><span>Download</span></a>
              <a href="menu">Documentation</a>
              <a href="http://odfaeg.yourboardpro.com/index.php">Forum</a>
              <a href="https://github.com/LaurentDuroisin/ODFAEG" class="code">View Odfaeg on GitHub</a>
              <a href="cv">CV</a>
              <a href="tfe">Travail de fin d'études</a>
            </div>
          <span class="blc"></span><span class="trc"></span>
        </div>
          <article class="markdown-body">
  <body>
    <h1>L`interet principal des composants de rendu.</h1>
    <p>
      ODFAEG possède plusieurs composants de rendu, certains permettent de dessiner des types d'entités de manière différentes, d'autres<br/> 
      permettent de dessiner un effet (une lumière par exemple) à l'aide des entités qui leurs sont fournis.<br/>
      Voici une présentation des différents type de composants de rendu géré par ODFAEG actuellement : <br/>
      <li>PerPixelLinkedListRenderComponent : dessine les entités dans n'importe quel ordre tout en gérant la transparence. (Order independant transparency).</li>
      <li>ReflectRefractRenderComponent : dessine le reflet des entités qui reflète ou réfracte les rayons de lumière.</li>
      <li>LightRenderComponent : dessine des lumières en fonction des entités qui lui sont fournies.</li>
      <li>ShadowRenderComponent : dessine des ombres en fonction des entités qui lui sont fournies.</li>      
      </p>
      <p>
      <br/>      
      
      <h1>Créer des composants de rendus et les ajouter à la scene.</h1>
      <p>
       Pour créer un composant il faut appeler le constructeur d'une de ses 4 classes.<br/>
       Celui-ci prend 4 paramètres obligatoires : une référence vers la fenêtre de rendu de l'application, un nombre<br/>
       indiquant l'id du composant, 0 signifie que le composant de rendu sera afficher en premier, 1, en deuxième, etc...<br/>
       Le troisième paramètre est une chaînes de caractère qui indique le type d'entité(s) que l'on souhaite dessiner sur le composant.<br/>
       "E_DECOR" par exemple signifie que l'on va dessiner toutes les entités de type E_DECOR sur le composant.<br/>
       On peut dessiner plusieurs type d'entités, grâce au + : "E_DECOR+E_WALL" qui va dessiner toutes les entités<br/>
       de type décors et murs sur les composants.<br/>
       "*-E_CARACTER" va dessiner toutes les entités sauf celles de type E_CARACTER.<br/>
       Bref vous l'avez compris, ceci n'est pas du tout compliqué à définir.<br/>
       Et le dernier paramètre qui sont les paramètres d'opengl.<br/>
       Pour ajouté un composant de rendu il faut appelé la méthode addComponent de la classe RendercomponentManager comme ceci :
        PerPixelLinkedListRenderComponent *frc1 = new PerPixelLinkedListRenderComponent(getRenderWindow(),0, "E_BIGTILE", ContextSettings(0,0,4,4,6));
        //Création du composant de rendu.
        getRenderComponentManager().addComponent(frc1); 
        //Récupère le gestionnaire des composants de rendu de l'application et ajoute le composant.
       <p>
       Le gestionnaire de composant va se charger de dessiner tout les composants sur la fenêtre de rendu, et va, également, <br/>
       traiter tout les événements interne liés aux composants comme par exemple le rafraichissement des composants!<br/>
       
       A chaque tour de boucle vous devez définir ce qui devra être dessiner sur les composants de rendu.<br/>
       Ceci se fait dans la méthode onRender, qui à chaque tour de boucle va rechercher les entités présente dans<br/>
       la vue du composant via le gestionnaire d'entités et les charger sur le composant de rendu pour ensuite, les dessiner.<br/>
       
        World::drawOnComponents("E_BIGTILE", 0);<br/>
        World::drawOnComponents("E_WALL+E_DECOR+E_ANIMATION+E_CARACTER", 1);<br/>
        </p>
      <p>
      Le gestionnaire d'entité du framework charge donc toutes les entités visible sur les composants de rendu, et ensuite il<br/> 
      recherche toutes les entités qui sont visibles sur la fenêtre de rendu!<br/>
      
      Vous n'êtes donc pas obligé de dessiner directement sur les composants de rendu et utiliser la méthode World::getVisibleEntities("expression")<br/>
      mais ceci est déconseillé si vous ne voulez pas vous embêter avec la semi-transparence, le calcul des normales, etc...<br/>
    <p>Les différents type de composants</p>
    ReflectRefactRenderComponent : Ce composant dessine le reflet des entités réflectable ou réfractable comme l'eau par exemple, pour qu'une
    entité soit refractable il faut appeler la méthode setRefractable sur l'entité : tile->setRefractable(true). (<br/> 
    Il faut passer le type des entités réfractable ou réflectable ainsi que le type des entités à refléter ou à réfracter.<br/>
    PerPixelLinkedListRenderComponent : dessine les entités dans n'importe quel ordre, tout en gérant la transparence à l'aide d'une <br/> 
    "per pixel linked list"! Pour celà il suffit de passer le type des entités à dessiner.
    ShadowRenderComponent : il vous faut passer toutes les entités pour lesquelles vous souhaiter dessiner les ombres.<br/>
    LightRendercomponent : il vous faut passer toutes les entités qui sont des lumières, si vous passer des autres entités,<br/>
    les normales seront calculées et si l'entité se trouve devant la lumière elle cachera la lumière.<br/>
      </p>
  
  </body>
  </html>
