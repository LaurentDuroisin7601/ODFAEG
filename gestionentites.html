
<!doctype html>
<!-- The Time Machine GitHub pages theme was designed and developed by Jon Rohan, on Feb 7, 2012. -->
<!-- Follow him for fun. http://twitter.com/jonrohan. Tail his code on https://github.com/jonrohan -->
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <link rel="stylesheet" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" href="stylesheets/github-dark.css">
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script type="text/javascript" src="javascripts/script.js"></script>
    <title>Odfaeg</title>
    <meta name="description" content="ODFAEG">
    <meta name="viewport" content="width=device-width,initial-scale=1">
  </head>
  <body>
  <div class="wrapper">
  <header>
    <h1 class="title">LastProject : ODFAEG</h1>
    <div id="container">
    <p class="tagline">Le gestionnaire d'entités : </p>
  </header>
  <div id="container">
        <div id="main" role="main">
          <div class="download-bar">
            <div class="inner">
              <a href="https://github.com/LaurentDuroisin/ODFAEG/tarball/master" class="download-button tar"><span>Download</span></a>
              <a href="https://github.com/LaurentDuroisin/ODFAEG/zipball/master" class="download-button zip"><span>Download</span></a>
              <a href="menu">Documentation</a>
              <a href="http://odfaeg.yourboardpro.com/index.php">Forum</a>
              <a href="https://github.com/LaurentDuroisin/ODFAEG" class="code">View Odfaeg on GitHub</a>
              <a href="cv">CV</a>
              <a href="tfe">Travail de fin d'études</a>
            </div>
          <span class="blc"></span><span class="trc"></span>
        </div>
        <article class="markdown-body">
    <h1>Le monde</h1>
    <p>
      Comme pour tout les modules de ODFAEG (Coeur, Graphique, Physique, Audio, Réseau) ODFAEG possède une classe statique <br/>
      qui permet d'intéragir avec les autres modules.<br/>
      Cette classe s'appelle World, et cette classe peut contenir un ou plusieurs gestionnaire d'entités.<br/>
      Etant donné que le monde peut être très grand il est nécessaire de charger et de libérer des entités au fur et à mesure <br/>
      de l'exécution de l'application afin de ne pas encombre la RAM, pour cela on peut choisir d'ajouter un ou plusieurs <br/>
      gestionnaires d'entités qui se chargerons d'afficher une partie du monde, et les libérer.<br/>
      Grâce à la sauvegarde on verra plus tard qu'il est très facile de sauvegarder et de restaurer une zone du monde.<br/>
      Un gestionnaire d'entité peut donc être considéré comme une zone, le monde peut être composé d'un nombre indéfini de zones.<br/>
    </p>
      
    <h1>Les gestionnaires d'entités.</h1>
      <p>
      Ce sont les gestionnaires d'entités qui vont contenir toutes les entités des différentes zones et non pas le monde!<br/>
      Les gestionnaires d'entité possèdent plusieurs propriétés : <br/>
      <ul>
      <li>Une taille.</li>
      <li>Une matrice de changement de base.</li>
      <li>Une liste d'entités.</li>
      <li>La liste des entités visibles dans la fenêtre de rendu.</li>
      <li>Un gestionnaire de composant.</li>           
      </ul>
      </p>
      
      <h2>La grille et la matrice de changement de base.</h2>
      <p>
      Je pense que je vous dois quelques explications à son sujet, il est possible que dans un monde à deux dimentions <br/>
      on souhaite dessiner des objets en trois dimentions, ceci s'appelle faire de la 2D isométrique (ou dimétrique), <br/>
      pour ce faire, lorsque vous vous positionner à un endroit dans le monde, le système de coordonnées change.<br/>
      ODFAEG utilise pour des raisons de performance une grille dans laquelle sont ajoutées toutes les entités, cette grille <br/>
      est en fait un ensemble de cases délimitées par un système d'axe, hors en 2D isométrique, les axes changent de direction!<br/>
      (La grille est donc de travers)<br/>
      
      Il faut donc pouvoir passer d'un système de coordonnée en 2D à un système de coordonnée en 2D isométrique lorsque l'on <br/>
      veut récupérer une ou plusieurs entités à un endroit précis!<br/>
      La matrice de changement de base permet de faire cela!<br/>
      
      <i>La grille est redimentionnée automatiquement suivant la taille de la zone, la taille de la zone est calculée automatiquement suivant<br/>
      la position et la taille de toutes les entités!<br/>
      Lorsque une entités est transformée, elle est automatiquement remise à jour dans la grille grâce aux méthodes moveEntity, rotateEntity et scaleEntity de la classe World!</i><br/>
      </p>
      
      <h2>Créer et ajouter un gestionnaire d'entité dans le monde</h2>
      <p>
      Le gestionnaire d'entité par défaut de ODFAEG s'appelle odfaeg::graphic::Scene!<br/>
      Le constructeur de la classe Scene attend 5 paramètres : <br/>
      <ul>
      <li>Le premier est un pointeur vers le gestionnaire de composants de l'application, celui-ci peut être récupérer avec la méthode getRenderComponentManager</li>
      <li>Le second est un nom qui référencera la scène.</li>
      <li>Les trois derniers sont la taille des cases de la grille de la map. (vous devez mettre 0 pour le dernier paramètre si la scène est en 2D)</li>
      </ul>
      Pour faire de la 2D iso, vous devez changer la matrice de changement de base qui est configurée pour de la 2D par défaut, pour se faire il suffit de faire :
      <pre><code>BaseChangementMatrix bm;
        bm.set2DIsoMatrix();
        theMap->setBaseChangementMatrix(bm);</code></pre>
      
      Pour ajouter un gestionnaire d'entité dans le monde vous devez appeler la méthode addSceneManager de la classe World!<br/>
      Si vous souhaiter travaille avec l'entity manager vous devez le sélectionner avec la méthode setCurrentSceneManager, cette<br/>
      méthode attend un paramètre : le nom de la map.<br/>
        <pre><code>getWorld()->addSceneManager(theMap);
        getWorld()->setCurrentSceneManager("Map test");</code></pre>
      
      Vous pouvez alors ajouter des entités avec la méthode addEntity de la classe World comme vu dans le chapitre sur les entités.<br/>
      </p>
      <h2>Les différents méthodes utiles de la classe World : </h2>
      
      <p>
      removeEntity : efface l'entité de la grille sans la libérer de la mémoire.<br/>
      deleteEntity : efface l'entité de la grille et libère l'entité de la mémoire.<br/>
      getVisibleEntities : récupère toutes les entités visible d'un certain type.<br/>
      moveEntity : déplace une entité de x, y et z unités.<br/>
      collide : test si une entité est en collision avec une autre, il y a trois version de cette méthode, la première<br/>
      test si le volume de collision d'une entité est en collision avec l'entité passée, la seconde test si le volume de<br/>
      collision d'une entité est en collision avec un point, et la troisième test si une entité est sur la trajectoire <br/>
      d'une autre entité.<br/>
      generateMap : génère un terrain avec au sol la liste de tile et au bord la liste de mur, dans une zone passée.<br/>
      La taille d'une tile peut être plus grande que celle d'un carré du terrain, ceci permet de faire des effets de transitions<br/>
      sur les bords!<br/>
      getPath : Récupère la trajectoire la plus courte entre une entité et un point. (En tenant compte des collisions)<br/>
      </p>
      </article>
      </div>
      </div>
      </div>
  </body>
</html>
