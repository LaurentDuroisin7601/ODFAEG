<!doctype html>
<!-- The Time Machine GitHub pages theme was designed and developed by Jon Rohan, on Feb 7, 2012. -->
<!-- Follow him for fun. http://twitter.com/jonrohan. Tail his code on https://github.com/jonrohan -->
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <link rel="stylesheet" href="stylesheets/stylesheet.css" media="screen">
  <link rel="stylesheet" href="stylesheets/github-dark.css">
  <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
  <script type="text/javascript" src="javascripts/script.js"></script>
  <title>Odfaeg</title>
  <meta name="description" content="ODFAEG">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  </head>
  <body>
    <div class="wrapper">
    <header>
      <h1 class="title">LastProject : ODFAEG</h1>
      <p class="tagline">Gestion des commandes </p>
    </header>
    <div id="container">
        <div id="main" role="main">
          <div class="download-bar">
            <div class="inner">
              <a href="https://github.com/LaurentDuroisin/ODFAEG/tarball/master" class="download-button tar"><span>Download</span></a>
              <a href="https://github.com/LaurentDuroisin/ODFAEG/zipball/master" class="download-button zip"><span>Download</span></a>
              <a href="menu">Documentation</a>
              <a href="http://odfaeg.yourboardpro.com/index.php">Forum</a>
              <a href="https://github.com/LaurentDuroisin/ODFAEG" class="code">View Odfaeg on GitHub</a>
              <a href="cv">CV</a>
              <a href="tfe">Travail de fin d'études</a>
            </div>
          <span class="blc"></span><span class="trc"></span>
        </div>
          <article class="markdown-body">
      <h1>Création de fonctions de callback.</h1>
        <p>
        ODFAEG possède une classe similaire à std::function, cette classe est capable de pouvoir stocker n'importe<br/>
        quel type de pointeur sur fonction et de paramètre dans le but d'appeler la fonction plus tard.<br/>
        Contrairement à std::function et à std::bind, la classe odfaeg::core::FastDelegate n'attend que le type<br/>
        de retour de la fonction en paramètre template, ceci permet de pouvoir faire des tableaux de foncteurs<br/>
        retournant un même type d'objet.<br/>
        En général il existe deux type de foncteurs dans les frameworks pouvant créer leur propre type d'événements : <br/>
        Les slots : ce sont des foncteurs ne retournant rien, il ne font que d'appeler un foncteur lorsqu'un événement <br/>
        est déclenché.<br/>
        Les signaux : ceux-ci retournent un booléen qui indique si un signal a été émis ou pas, et si le signal a été émis<br/>
        alors le slot est appelé.<br/>
        C'est le cas par exemple de la librairie QT mais celles-ci nécessite de faire appel à un générteur externe afin de <br/>
        générer des fichiers .moc, avec ODFAEG, tout ce fait à la compilation, il n'y a donc pas besoin de générer de .moc!<br/>
        </p>
        <p>
        Pour créer un slot ou un signal avec ODFAEG il suffit de définir un objet de type odfaeg::core::FastDelegate <br/>
        et de lui fournir en paramètre template le type de retour du foncteur, voici un example de code source qui permet<br/>
        de créer, différent foncteurs à l'aide de la classe odfaeg::core::FastDelegate!<br/>
        </p>
        
        <pre><code>
          #include<iostream>
          #include<string>
          #include <fstream>
          #include <functional>
          #include "odfaeg/Core/fastDelegate.h"
          #include "odfaeg/Core/serialization.impl"
          using namespace std::literals;
          using namespace std::placeholders;
           
          void foo(int i, int j)
          { std::cout << i << j; }
           
          struct A {
              A() {
                  var = 10;
              }
                  void foo(int i)
                  { std::cout << i; }
                  template <typename A>
                  void serialize (A & ar) {
                  ar(var);
                  }
                  int var;
          };
           
          struct B {
              B() {
                  c = "serialize base";
              }
                  virtual void foo()
                  { std::cout << 1; }
                  virtual void print() {
                  std::cout<<c<<std::endl;
                  }       
                  virtual ~B();
                  std::string c;  
          };
           
          B::~B(){}
           
          struct C : B {
              C () {
                  c = "serialize derived";
              }
              void foo();
              void print () {
                  B::print();
                  std::cout<<c<<std::endl;
              }   
              std::string c;
          };
           
          void C::foo(){ std::cout << 2; }
          
          int main (int argv, char* argc[]) {
              void(*f)(int, int) = &foo;
              odfaeg::FastDelegate<void> f1(f, 3, 4);
              f1.setParams(5, 6);
                  f1();
                  std::cout << std::endl;
           
                  odfaeg::FastDelegate<void> f2(
                          [](int i, int j){ std::cout << i << j; },
                          7,8
                  );
                  f2();
                  f2.setParams(9,10);
                  f2();
                  std::cout << std::endl;
           
                  int i = 11;
                  odfaeg::FastDelegate<void> f3(
                          [i](int j){ std::cout << i << j; },
                          12
                  );
                  f3();
                  f3.setParams(13);
                  f3();
                  std::cout << std::endl;
           
                  A a;
                  odfaeg::FastDelegate<void> f4(&A::foo,&a,14);
                  f4();
                  f4.setParams(&a,15);
                  f4();
                  std::cout << std::endl;
                  odfaeg::FastDelegate<void> f5 = f1;
                  f5();
                  f5=f3;
                  f5();
                  std::cout << std::endl;
           
                  C c;
                  B* b = &c;
                  odfaeg::FastDelegate<void> f6(&C::foo,&c);
                  f6();
                  f6.setParams(b);
                  f6();
                  std::cout << std::endl;
           
                  odfaeg::FastDelegate<void> f7(D(),16);
                  f7();
                  f7.setParams(17);
                  f7();
                  std::cout << std::endl;
           
                  odfaeg::FastDelegate<void> f8(bar,"ab"s);
                  f8();
                  f8.setParams("abc"s);
                  f8();
                  std::cout << std::endl;
                  int pi = 1;
              odfaeg::FastDelegate<void> f9(foo, &pi);
                  f9();
                  std::cout << std::endl;
                  pi=2;
                  f9();
                  std::cout << std::endl;
                  odfaeg::FastDelegate<int> f10(goo,18);
                  std::cout << f10();
                  f10.setParams(19);
                  std::cout << f10();
                  std::cout << std::endl;
                  void(*fu)(int&) = &foo;
                  int vi=1;
                  odfaeg::FastDelegate<void> f11(fu, std::ref(vi));
                  f11();
                  std::cout << std::endl;
                  vi=2;
                  f11();
                  std::cout<<std::endl;
                  return 0;
          }
        </code></pre>
        <p>
        ODFAEG permet également l'utilisation de placeholders pour les slot et les signaux.<br/>
        </p>
        <pre><code>
          void f (int i, int j, int l) {
              std::cout<<"i : "<<i<<" j : "<<j<<" l : "<<l<<std::endl;
          }
          int main (int argv, char* argc[]) {
          	odfaeg::FastDelegate<void> fd(&f, 1, 2, odfaeg::ph<0,int>()) ;
          	fd.bind(3);
          	fd() ;
          }
        </code></pre>
        <h1>Création des commandes et des actions.</h1>
        
          <h2>Création d'actions.</h2>
          <p>
          Les foncteurs de ODFAEG sont très pratique pour créer ses propres type de signaux et de slots, malheureusement, ils<br/>
          ne permettent pas d'appeler un slots lorsque un ou plusieurs événements système (événements SFML) sont déclenchés.</br>
          Heureusement ODFAEG possède également une classe permettant de créer ses propres événements utilisateurs à partir <br/>
          d'événements système!<br/>
          Cette classe s'appelle odfaeg::core::Action!<br/>
          Voici par exemple comment créer une action qui va se déclencher lorsque l'une ou plusieurs de ses quatre touches (Z, Q, S, D) <br/>
          est enfoncée : <br/>
          </p>
          <pre><code>
            Action a1 (Action::EVENT_TYPE::KEY_HELD_DOWN, sf::Keyboard::Key::Z);
            Action a2 (Action::EVENT_TYPE::KEY_HELD_DOWN, sf::Keyboard::Key::Q);
            Action a3 (Action::EVENT_TYPE::KEY_HELD_DOWN, sf::Keyboard::Key::S);
            Action a4 (Action::EVENT_TYPE::KEY_HELD_DOWN, sf::Keyboard::Key::D);
            Action combined (a1 || a2 || a3 || a4);
          </code></pre>
          <p>
          Comme pour les conditions, ou peut combiner plusieurs actions à l'aide des opérateurs logiques ||, |, && et !.<br/>
          La sémantique est la même que pour les conditions c'est à dire que l'événement utilisateur sera déclenché si<br/>
          l'une des quatre touche ou plusieurs seront enfoncées.<br/>
          
          Pour les touches et le boutons il y a 3 types dévénements :<br/>
          KEY/BUTTON_HELD_DOWN signifie que l'action sera déclenchée tant que la touche ou le bouton restera enfoncé.<br/>
          KEY/BUTTON_PRESSED_ONCE signifie que l'action sera déclenchée lorsque l'on appuira sur la touche ou le bouton.<br/>
          KEY_BUTTON_RELEASE signifie que l'action sera déclenchée lorsque l'on relâchera la touche ou le bouton.<br/>
          </p>
          <p>
          Voila maintenant vous savez comment définir des signaux, des slots ainsi que des actions.<br/>
          Maintenant il va falloir indiquer quel slot appeler lorsque une action et/ou un signal est/sont déclenché(s).<br/>
          </p>
          
          <h2>Création des commandes</h2>
          <p>
          Pour ce faire il faut créer un objet de type odfaeg::core::Command, cette classe possède trois constructeurs : <br/>
          Le premier permet de lier une action à un slot, le second permet de lier un signal à un slot, et le dernier permet <br/>
          de lier une action et un signal à un slot. (un exemple) <br/>
          Command moveCommand(combined, FastDelegate<void>(&MyAppli::keyHeldDown, this, sf::Keyboard::Key::Unknown, realTime.restart()));<br/>
          Ici par exemple, la fonction keyHeldDown de la classe MyAppli sera appelée lorsque l'une ou plusieurs des quatre touches<br/>
          (A, Z, S, D) sera enfoncée.<br/>
          </p>
          <p>
          Evidemment comme tout foncteur il faut lui passer des paramètres : this qui est le pointeur sur l'application courante, <br/>
          pour la touche je mets sf::Keyboard::Unknown car aucune touche ne peut être traitée lors de la création de la commande. <br/>
          Et le dernier paramètre est juste le temps écoulé depuis le dernier appel à la méthode exec.<br/>
          </p>
          <p>
          Voici un autre exemple qui va exécuter la commande si la souris se trouve dans une zone particulière de la fenêtre.<br/>
          
          Command mouseInsideCommand(FastDelegate<bool>(&MyAppli::mouseInside,this,Vector2f(-1, -1)),<br/>
          FastDelegate<void>(&MyAppli::onMouseInside, this, Vector2f(-1,-1)));<br/>
          
          Et une dernière qui va appeler la fonction onMouseInside si l'on a cliqué dans la zone avec le bouton <br/>
          gauche de la souris : <br/>
          </p>
          
          <pre><code>
          Action action(Action::EVENT_TYPE::MOUSE_PRESSED_ONCE,sf::Mouse::Left);
          Command mouseInsideLeftPressedCommand(action,FastDelegate<bool>(&MyAppli::mouseInside,this,Vector2f(-1, -1)), FastDelegate<void>(&MyAppli::onMouseInside, this, Vector2f(-1,-1)));
          </code></pre>
          
          <h2>Connexion et changement des paramètres.</h2>
          <p>
          Maintenant il ne reste plus qu'à connecter la commande au gestionnaire d'événements, le gestionnaire d'événement <br/>
          va vérifier à chaque tour si une commande n'a pas été déclenchée, et si oui, il va exécuter la commande en lui passant<br/> 
          la valeur des paramètres que l'on a défini lors de la création de la commande.<br/>
          Chaque application possède donc un gestionnaire d'événement, pour le récupérer il suffit d'appeler la méthode getListener() <br/>
          de la classe odfaeg::core::Application.<br/>
          Chaque commande est référencée par un nom (de type std::string) qui est le nom de la connexion.<br/>
          getListener().connect(«mouseInsideCommand»,mouseInsideCommand);<br/>
          </p>
          <p>
          Il serait bien de pouvoir changer la valeur des paramètres des slots et des signaux à chaque tour de boucle, <br/>
          pour que la fonction reçoive la bonne position de la souris à chaque tour de boucle.<br/>
          Les méthodes setCommandSlotParams et setCommandSigParams permettent de faire cela, dans le cas de placeholders,<br/>
          les méthodes s'appellent bindCommandSlotParams et bindCommandSigParams.<br/>
          Un exemple : <br/>
          getListener().setCommandSigParams("MouseInside", this, mousePos); <br/>
          
          <i>Dans le cas des actions combinées, le slot ne sera appelé qu'une seule fois par tour de boucle, si vous voulez<br/>
          appelé le slot plusieurs fois si plusieurs touche sont enfoncée alors il faudra créer une commande par touche.</i><br/>
          
          Voilà maintenant vous savez comment créer n'importe quel type d'événement avec ODFAEG. <br/>
          </p>
        </article>
      </div>
    </div>
  </div>
  </body>
</html>
